{
	"name": "Explore a relational data warehouse",
	"properties": {
		"folder": {
			"name": "dp-203-08-Explore-data-warehouse"
		},
		"content": {
			"query": "/* This exercise is shared with the DP-500 (Azure Data Analyst) curriculum and is available at\n   https://microsoftlearning.github.io/DP-500-Azure-Data-Analyst/Instructions/labs/03-Explore-data-warehouse.html\n\nExplore the data warehouse schema\n=================================\n- Make sure the sqldwh has been resumed\n- View the tables in the database\n\nA relational data warehouse is typically based on a schema that consists of fact and dimension tables. \nThe tables are optimized for analytical queries in which numeric metrics in the fact tables are aggregated \nby attributes of the entities represented by the dimension tables - for example, enabling you to aggregate\nInternet sales revenue by product, customer, date, and so on.\n\nExpand the dbo.FactInternetSales table and its Columns folder to see the columns in this table. \nNote that many of the columns are keys that reference rows in the dimension tables. Others are numeric values\n(measures) for analysis. The keys are used to relate a fact table to one or more dimension tables, \noften in a star schema; in which the fact table is directly related to each dimension table (forming a \nmulti-pointed “star” with the fact table at the center).\n\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'FactInternetSales' order by ordinal_position\n\n/*\nView the columns for the dbo.DimPromotion table, and note that it has a unique PromotionKey that uniquely\nidentifies each row in the table. It also has an AlternateKey. Usually, data in a data warehouse has been \nimported from one or more transactional sources. The alternate key reflects the business identifier for the \ninstance of this entity in the source, but a unique numeric surrogate key is usually generated to uniquely \nidentify each row in the data warehouse dimension table. One of the benefits of this approach is that it \nenables the data warehouse to contain multiple instances of the same entity at different points in time \n(for example, records for the same customer reflecting their address at the time an order was placed).\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'DimPromotion' order by ordinal_position\n\n/*\nView the columns for the dbo.DimProduct, and note that it contains a ProductSubcategoryKey column, \nwhich references the dbo.DimProductSubcategory table, which in turn contains a ProductCategoryKey \ncolumn that references the dbo.DimProductCategory table. In some cases, dimensions are partially normalized \ninto multiple related tables to allow for different levels of granularity - such as products that can be \ngrouped into subcategories and categories. This results in a simple star being extended to a snowflake schema, \nin which the central fact table is related to a dimension table, which is turn related to further dimension tables.\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'DimProduct' order by ordinal_position\nselect column_name, data_type from information_schema.columns where table_name = 'DimProductSubcategory' order by ordinal_position\nselect column_name, data_type from information_schema.columns where table_name = 'DimProductCategory' order by ordinal_position\n\n/*\nView the columns for the dbo.DimDate table, and note that it contains multiple columns that reflect different temporal \nattributes of a date - including the day of week, day of month, month, year, day name, month name, and so on. \nTime dimensions in a data warehouse are usually implemented as a dimension table containing a row for each of \nthe smallest temporal units of granularity (often called the grain of the dimension) by which you want to aggregate \nthe measures in the fact tables. In this case, the lowest grain at which measures can be aggregated is an individual date, \nand the table contains a row for each date from the first to the last date referenced in the data. The attributes in the \nDimDate table enable analysts to aggregate measures based on any date key in the fact table, using a consistent set of \ntemporal attributes (for example, viewing orders by month based on the order date). The FactInternetSales table contains \nthree keys that relate to the DimDate table: OrderDateKey, DueDateKey, and ShipDateKey.\n*/\n\nselect column_name, data_type from information_schema.columns where table_name = 'DimDate' order by ordinal_position\n\n/*\nQuery the data warehouse tables\n===============================\n\nNow that you have explored some of the more important aspects of the data warehouse schema, you’re ready to to query \nthe tables and retrieve some data.\n\n1. Query fact and dimension tables\n----------------------------------\nNumeric values in a relational data warehouse are stored in fact tables with related dimension tables that you can use \nto aggregate the data across multiple attributes. This design means that most queries in a relational data warehouse \ninvolve aggregating and grouping data (using aggregate functions and GROUP BY clauses) across related tables (using JOIN clauses).\n\nThe following query should show the Internet sales totals for each year. This query joins the fact table for Internet sales \nto a time dimension table based on the order date, and aggregates the sales amount measure in the fact table by \nthe calendar month attribute of the dimension table.\n*/\n\nSELECT  d.CalendarYear AS Year,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nGROUP BY d.CalendarYear\nORDER BY Year;\n\n/*\nModify the query as follows to add the month attribute from the time dimension, and then run the modified query.\nNote that the attributes in the time dimension enable you to aggregate the measures in the fact table at multiple \nhierarchical levels - in this case, year and month. This is a common pattern in data warehouses.\n*/\n\nSELECT  d.CalendarYear AS Year,\n        d.MonthNumberOfYear AS Month,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nGROUP BY d.CalendarYear, d.MonthNumberOfYear\nORDER BY Year, Month;\n\n/*\nModify the query as follows to remove the month and add a second dimension to the aggregation, and then run \nit to view the results (which show yearly Internet sales totals for each region):\n\nNote that geography is a snowflake dimension that is related to the Internet sales fact table through the customer\ndimension. You therefore need two joins in the query to aggregate Internet sales by geography.\n*/\n\nSELECT  d.CalendarYear AS Year,\n        g.EnglishCountryRegionName AS Region,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nJOIN DimCustomer AS c ON i.CustomerKey = c.CustomerKey\nJOIN DimGeography AS g ON c.GeographyKey = g.GeographyKey\nGROUP BY d.CalendarYear, g.EnglishCountryRegionName\nORDER BY Year, Region;\n\n/*\nModify and re-run the query to add another snowflake dimension and aggregate the yearly regional sales by product category:\n*/\n\nSELECT  d.CalendarYear AS Year,\n        pc.EnglishProductCategoryName AS ProductCategory,\n        g.EnglishCountryRegionName AS Region,\n        SUM(i.SalesAmount) AS InternetSalesAmount\nFROM FactInternetSales AS i\nJOIN DimDate AS d ON i.OrderDateKey = d.DateKey\nJOIN DimCustomer AS c ON i.CustomerKey = c.CustomerKey\nJOIN DimGeography AS g ON c.GeographyKey = g.GeographyKey\nJOIN DimProduct AS p ON i.ProductKey = p.ProductKey\nJOIN DimProductSubcategory AS ps ON p.ProductSubcategoryKey = ps.ProductSubcategoryKey\nJOIN DimProductCategory AS pc ON ps.ProductCategoryKey = pc.ProductCategoryKey\nGROUP BY d.CalendarYear, pc.EnglishProductCategoryName, g.EnglishCountryRegionName\nORDER BY Year, ProductCategory, Region;\n\nselect * from DimCustomer",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "sqldwh",
				"poolName": "sqldwh"
			},
			"resultLimit": -1
		},
		"type": "SqlQuery"
	}
}